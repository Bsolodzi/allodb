---
title: "Integrating bmss and allodb"
author: "maurolepore@gmail.com"
date: "2018-03-19"
output:
  rmarkdown::html_document:
    theme: united
    toc: true
---

```{r setup, include=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  echo = TRUE,
  comment = "#>",
  collapse = TRUE,
  cache = TRUE,
  out.width = "70%",
  fig.align = "center",
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold")
```

# OVerview

My goal is to explain what columns are missing from the current `equations` dataset. I'll show two examples, starting with a simplistic one.

```{r pkg}
library(tidyverse)
library(bmss)
library(allodb)
library(here)
```

# 1. Simplistic example

## Revisiting `biomass_per_indiv()`

Let's start with a little reminder of what the current code of __bmss__ does. 

This is a simplistic model of what the equations dataset might look like.

```{r}
eqn <- bmss::toy_default_eqn

eqn
```

Now say that we have a census dataset like this one:

```{r}
cns <- bmss::user_data

cns
```

We can calculate biomass with our currently naive `biomass_per_ind()` function.

```{r}
biomass_per_ind(cns, site = "site", sp = "sp", dbh = "dbh")
```

## Braking down `biomass_per_indiv()`

Let's brake down what `biomass_per_ind()` does to better understand what columns we need from the `equations` dataset.

* Step 1: Join the census data with the equations data.

```{r}
joint <- left_join(cns, eqn)

joint
```

To make things simpler, let's keep only the columns that matter.

```{r}
joint <- select(joint, dbh, eqn)

joint
```

* Step 2: Replace the string "dbh" of the column `eqn` with the corresponding value from the column `dbh`.

```{r}
joint <- mutate(
  joint, 
  eqn_replaced = str_replace(eqn, "dbh", as.character(dbh))
)

joint
```

* Step 3: Evaluate the equation strings in `eqn_replaced` to calculate biomass (`bmss`).

```{r}
dplyr::mutate(
  joint, 
  bmss = map_dbl(.data$eqn_replaced, ~eval(parse(text = .x), envir = joint))
)
```

# 2. An example that is a bit more realistic

The equations in the `equations` dataset have many parameters -- not only `dbh`. And we need one column for each of those parameters.

Let's glimpse the dataset, and focus on the `equation` column.

```{r}
glimpse(allodb::equations)
```

The column `equation` has many parameters, such as `a`, `b` and `c`. To show how the code may deal with these parameters, I'll create a small dataset with only the parameter `a`.

```{r}
joint2 <- tibble::tribble(
            ~eqn, ~a, ~dbh,
  "33 * dbh * a",  5,   10,
  "24 * dbh * a",  1,   15,
  "12 * dbh * a",  2,   23
)

joint2
```

And I will assume that this dataset is already merged with the user data, so it already has a `dbh` column -- that is, here I start at the step 2 above.

* Step 2: 
    * Replace the string "dbh" of the column `eqn` with the corresponding value from the column `dbh`.
    * Same with `a`.

```{r}
joint2 <- mutate(
  joint2, 
  eqn_replaced = str_replace(eqn, "dbh", as.character(dbh)),
  eqn_replaced = str_replace(eqn_replaced, "a", as.character(a))
)

joint2
```

* Step 3: Evaluate the equation strings in `eqn_replaced` to calculate biomass (`bmss`).

```{r}
dplyr::mutate(
  joint2, 
  bmss = map_dbl(.data$eqn_replaced, ~eval(parse(text = .x), envir = joint2))
)
```
